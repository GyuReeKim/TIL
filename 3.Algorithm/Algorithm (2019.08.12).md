# Algorithm (2019.08.12)

> APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.

### 무엇이 좋은 알고리즘인가?

1. 정확성: 얼마나 정확하게 동작하는가
2. 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
3. 메모리 사용량: 얼마나 적은 메모리를 사용하는가
4. 단순성: 얼마나 단순한가, 어떤 사람이 보더라도 이해할 수 있는 코드를 짜는 것이 중요하다.
5. 최적성: 더 이상 개선할 여지없이 최적화되었는가



우리의 목표는 널리 알려진 알고리즘을 추려서 적용해보는 연습을 하는 것이다.



##  어떤 알고리즘을 사용해야 하는가?

### 알고리즘의 성능 분석 필요

많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다.

알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다.



## 시간 복잡도(Time Complexity)

실제 걸리는 시간을 측정한다.

실행되는 명령문의 개수를 계산한다.



### 빅-오(O) 표기법 (Big-Oh Notation)

시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시한다.

계수(Coefficient)는 생략하여 표시한다.



## 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조다.

순서를 따질 수 있는 형태로 저장하는 것이 편리하다. '선형 자료구조'라고 한다.



## 정렬

### 대표적인 정렬 방식의 종류

버블 정렬: 시간과 관계 없이 정렬만 하면 될 때 사용한다.

선택 정렬: 시간과 관계 없이 정렬만 하면 될 때 사용한다.

카운팅 정렬

퀵 정렬

삽입 정렬

병합 정렬



### 버블 정렬

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식



#### 정렬 과정

1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
3. 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬이라고 한다.



#### 시간 복잡도

- O(n^2)



## 문제풀이

### 숫자 카드

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    num = input()
    for i in range(0, N):
        print(num[i])
    card = [0] * 10
    for i in range(0, N):
        v = int(num[i])
        card[v] = card[v] + 1

    maxIdx = 0
    for i in range(0, 10):
        if(card[maxIdx]<=card[i]):
            maxIdx = i
    print('#{} {} {}'.format(tc, maxIdx, card[maxIdx]))
```



