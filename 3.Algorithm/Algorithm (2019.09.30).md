# Algorithm (2019.09.30)

## Computational Thinking

### 명제식

````  
p q p->q ~q ~p ~q->~p
T T  T    F  F   T
T F  F    F  T   T
F T  T    T  F   F
F F  T    T  T   T
````

```
p q ~p
T F  F

p q pVq 논리합 (OR) # 한 쪽이 참이면 결과도 참
T T  T
T F  T
F T  T
F F  F

p q p^q 논리곱 (AND) # 둘다 참일 경우에만 결과가 참
T T  T
T F  F
F T  F
F F  F
```

```
p->q
q->p 역 (converse)
~p->~q 이 (inverse)
~q->~p 대우 (contraposition) # 중요 명제식의 참 거짓 판별이 어려울 때, 대우의 참 거짓을 판별한다.
```

```
p q ~p q->~p p^(q->~p)
T T  F   F       F
T F  F   T       T
F T  T   T       F
F F  T   T       F
```

```
p q r ~q p^~q (p^~q)->r 
T T T  F   F      T
T T F  F   F      T
T F T  T   T      T
T F F  T   T      F
F T T  F   F      T
F T F  F   F      T
F F T  T   F      T
F F F  T   F      T
```

```
(p^~q)V(p^q) == p^(~qVq) == p^T == p

(pV~q)^(~pV~q) == (p^~p)V~q == FV~q == ~q
```

``` 
3n+5 홀수 (n이 짝수일 때)
3(2k)+5 = 2(3k)+2*2+1 = 2(3k+2)+1

n^2+n 짝수 (n이 홀수일 때)
(2k+1)**2 + (2k+1) = 4k**2 + 4k + 1 + 2k + 1 = 4k**2 + 6k + 2 = 2(2k**2 + 3k + 1)
```

```
n^2+5 짝수 (n이 홀수일 때)
(2k+1)**2+5 = 4k**2 + 4k + 1 + 5 = 2(2k**2 + 2k + 3)
```

```
n^2 홀수 (n이 홀수일 때)
(2k+1)**2 = 4k**2 + 4k + 1 = 2(2k**2 + 2k) + 1
```

```
n^2 + 5n + 3 홀수 (자연수 n일 때)
n이 짝수인 경우
4k**2 + 10k + 2 + 1 = 2(2k**2 + 5k + 1) + 1
n이 홀수인 경우
4k**2 + 4k + 1 + 10k + 5 + 3 = 2(2k**2 + 7k + 4) + 1
```

```
(대우로 증명)
n 3의 배수 (n^2가 3의 배수일 때)
n이 3k+1
9k**2 + 6k + 1 = 3(3k**2 + 2k) + `
n이 3k+2
9k**2 + 12k + 3 + 1 = 3(3k**2 + 4k + 1) + 1
```

```
n^2 8로 나눈 나머지 1 (n이 홀수일 때)
4k+1 = 2k + 1 + 2k
16k**2 + 8k + 1 = 8(2k**2 + k) + 1
4k+3 = 2k + 1 + 2k + 2
16k**2 + 24k + 9 = 8(2k**2 + 3k + 1) + 1
```

```
n^2 3으로 나눈 나머지 2가 아님 (자연수 n일 때)
어떤 자연수 3k, 3k+1, 3k+2
3k
9k**2
3k+1
9k**2 + 6k + 1 = 3(3k**2 + 2) + 1
3k+2
9k**2 + 12k + 4 = 3(3k**2 + 4k + 1) + 1
```

```
귀류법
가정이 모순된 것을 증명
유리수 + 무리수 = 무리수
```

```
root2 무리수
root2 = b/a # a와 b는 서로소인 정수
```

```
로그2의5 = 무리수
```

```
n = 1일 때 1(1+1)/2 = 1 이므로 성립한다.
n = k일 때 성립한다고 가정하면
1 + ... + k = k(k+1)/2

n = k+1
1 + ... + k + (k+1) = k(k+1)/2 + (k+1)
= (k+1)(k+2)/2
= (k+1)k/2 + (k+1)2/2
= ((k+1)k + 2(k+1))/2
= (k**2 + 3k + 2)/2
= (k+1)(k+2)/2

오른쪽 식에 k+1을 넣으면 (k+1)(k+1+1)/2
```

```
1**2 + ... + k**2
```

```
감염조건:
(1) 상하좌우 중 2개의 칸이 감염된 경우
(2) 상하좌우 중 3개의 칸이 감염된 경우
(3) 상하좌우 중 4개의 칸이 감염된 경우

감염되고 나면:
(1) 주변의 2개의 칸을 감염시킬 수 있음
(2) 주변의 1개의 칸을 감염시킬 수 있음
(3) 주변의 0개의 칸을 감염시킬 수 있음

s를 감염된 칸과 감염되지 않은 칸의 경계인 길이가 1인 부분으로 정의하면, s는 증가할 수 없다.

모든 칸이 감염되었다고 생각할 경우, s의 수는 체스판의 네 모퉁이가 되어 4n개가 되고, 
```

