# Algorithm (2019.09.10)

##  힙에서의 삭제

> 완전 이진 트리를 유지하는 것이 목표다.

append와 pop을 쓰면 연산이 느리다.

자식이 있다면 자식 중 큰것과 비교한다. 자식이 더 크면 자리를 바꾼다.

자신의 번호 * 2, 자신의 번호 * 2 + 1이 자식 번호다.

자신의 번호 // 2가 부모 번호다.



## 섬

A

​	Ar1-Ac1				Ac2



​	Ar2



B

​	Br1-Bc1				Bc2



​	Br2

```
# A 오른쪽에 B가 있고 다리를 놓을 수 있으려면
if Ac2 < Bc1:
	if Ar1 <= Br1 <= Ar2 or Ar1 <= Br2 <= Ar2
```

```
# 각 섬사이의 거리를 저장한 인접행렬 adj[][]를 만든다.

# MST(최소 스패닝 트리)의 거리 합계를 구한다. MST에 포함되지 않은 섬이 있으면 -1을 출력한다.
# MST의 최소합계를 찾는 알고리즘(프림, 크루스컬) 중 하나를 적용해본다.
```

```
# 프림 알고리즘의 경우
(1) 1번 노드를 MST에 포함 mst[1] = 1
(2) MST에 포함된 노드에 인접하고
	아직 MST에 포함되지 않은 노드 중 거리가 최소인 노드를 선택하고 MST에 포함시킨다.
(3) (2)를 반복한다. 선택되는 노드가 없는 경우 중지.
(4) 모든 노드가 MST에 포함되어 있으면 거리의 합을 출력.
	포함되지 않은 노드가 있으면 -1 출력
```



## 공통조상

(1) 자식을 인덱스로 부모 저장

(2) N1의 조상 i를 빈 배열 a에 표시 a[i] = 1

(2) N2의 조상 j를 배열 a에서 확인 (a[j] == 1인 경우)

(4) a[j] == 1인 최초의 경우가 N1, N2에서 가장 가까운 공통 조상



```python
c = N1
while par[c] != 0:
    a[par[c]] = 1
    c = par[c]
c = N2
while a[c] == 0:
    c = par[c]
print(c)
```

