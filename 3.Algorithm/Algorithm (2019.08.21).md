# Algorithm (2019.08.21)

## 큐 (Queue)

> 큐는 push와 pop을 사용하지 않는다.

pop을 사용하면 새로운 리스트를 만들기 때문에 시간이 오래걸린다.



### BFS (너비 우선 탐색)

> 거리순 탐색

탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식이다.



#### 트리 구조

상황을 정리한 다음 그래프로 표현 가능하면 그래프로 풀고, 아니면 다른 방식으로 푼다.



#### BFS 알고리즘

```python
# 입력 파라미터: 그래프 G와 탐색 시작점 v
BFS(G, v) # 그래프 G,탐색 시작점 v
	큐 생성
    시작점 v를 큐에 삽입
    점 v를 방문한 것으로 표시
    while 큐가 비어있지 않은 경우
    	t <- 큐의 첫 번째 원소 반환
        for t와 연결된 모든 선에 대해
        	u <- t의 인접 정점
            u가 방문되지 않은 곳이면,
            u를 큐에 넣고, 방문한 것으로 표시
```



```python
q = [0]*9 # 내가 탐색 할 개수만큼 만들어준다.
front = -1
rear = -1
rear += 1 # enq(1) # 시작점 인큐
q[rear] = 1 # enq(1)
visited[1] = 1 # 시작점 방문 표시

while front != rear: # 큐가 비어있지 않으면
    front += 1
    t = q[front] # 디큐
    # t에 인접이고 방문하지 않은 정점이면
    # 주어진 상황에 맞게 완성..
    # t 주변의 모든 i에 대해
    	if visited[i] == 0 and t에 i가 인접:
            ... # enq(i)
            visited[i] = visited[t] + 1
```

거리 관련 문제는 BFS를 쓰면 쉽게 구할 수 있다.



#### 예시

출발지가 하나일 때...

출발지에 숫자 1을 넣어준다.

숫자 1의 '상, 우, 좌, 하'는 인접값이다.

1의 인접값을 찾는다. 인접값들을 인큐 한 다음, 1의 인접값들을 다 찾았다면 1을 디큐해준다.

거리가 2 이내인 경우를 구하려고 하면 필요한 값만 구하면 된다.

특정 노드를 디큐한 이후에 해야할 일 처리해줘야 한다.



## 문제풀이

0 0 1 1 1 1 0 1 1 0 1 1 1 0

(1) 1이 3개 연속된 경우는 몇 개?

주어진 리스트와 같은 길이의 used 리스트 생성

```python
for i: 0 -> N-3
	# arr[i]가 1이고 다른 연속구간에 포함되지 않으면 1이 몇 개 연속인지 확인
    m = i # 연속된 1의 시작인지 확인하는 위치
    w = 0 # 연속된 1의 길이
    while m < N and word[m] == 1 and used[m] == 0:
        used[m] = 1 # 연속된 1인지 확인된 구간
        m += 1
        w += 1
    if w == k:
        cnt += 1
```

가로와 세로로 각각 한번씩 돌려주면 된다.

