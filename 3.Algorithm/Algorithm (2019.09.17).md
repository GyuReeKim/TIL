# Algorithm (2019.09.17)

## 완전검색 & 그리디

작은 부분에 대한 해를 구하는 과정. 문법적으로는 재귀함수.

무한루프에 빠지지 않도록 주의해야 한다.

오름차순이면 제일 작은 값을 가져오고, 내림차순이면 제일 큰 값을 가져온다.



## 반복과 재귀

### 재귀적 알고리즘

재귀를 중지하는 부분과 재귀를 계속 호출하는 부분으로 나뉜다.

재귀 함수를 사용할 것이면 어떻게 사용할 것인가? 사용하지 않는다면 어떤식으로 코드를 작성할 것인가?



### 재귀호출에 대한 오해

재귀호출은 단순하게 반복하는 것은 아니며, 무한루프에 빠지기 쉽기에 조심해서 사용해야 한다.

재귀호출은 늘 같은 모양이 반복되는 것이다.

이번 호출이 마지막인지 더 밑으로 내려가는지 판단해야 하고, 몇번의 재귀함수 호출이 있어야 하는지 확인해야 한다.

각 단계에서의 상태와 값의 변화를 잘 확인해야 한다.

재귀호출을 잘못만들면 stack overflow가 발생하게 된다.

입력 값이 커질수록 (깊이가 깊어질수록) 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.

선택정렬은 재귀를 사용하지 않기위해 사용한다.



### 팩토리얼

재귀함수에는 보통 현재 단계의 변수와 목표값을 나타내는 변수를 갖고있다.

팩토리얼은 한개의 변수만을 갖고있다.

어떤 값을 받아서 어떤 값을 리턴할지 잘 판단해야 한다.



### 재귀 vs 반복

무한 반복시 재귀는 stack overflow가 발생하고, 반복은 CPU를 계속 사용한다.



## 완전 검색 기법

### 고지식한 방법 (brute-force)

모든 경우를 다 고려하는 방법.

대부분의 문제에 적용가능하다.



### 완전 검색

수행속도는 느리지만 해답을 찾아낼 확률이 높다.

실제 검정때는 완전 검색으로 해답을 도출하기만 하면 된다. (A형 기준, 효율은 필요없지만 중복 제거는 필수!)

완전 검색은 순열 생성과 관련이 있다. 순열 만드는 것은 생각보다 어려운 편이다. 만든 순열을 적용하는 것도 어렵다.



## 순열

```
[1] [2] [3] [4] [5]

5 * 4 * 3
[]  []  []
1	2
	3
	4
	5
2
3
4
5

5P3
```



팩토리얼의 경우 N개의 요소들에 대해서 n!개의 순열들이 존재한다. 따라서 시간 복잡도가 폭발적으로 증가한다.



재귀함수는 어쩔 수 없지만 함수보다는 풀어서 작성하는 것이 좋다.

가급적 함수호출을 줄이는 것이 좋다.



## 부분집합

### N개의 원소를 포함한 집합

모든 부분집합의 개수는 2^n (`1<<n`)개다.

n이 커질수록 부분집합의 개수가 기하급수적으로 커진다.

따라서 입력의 크기에 따라 접근방법을 다르게 해야한다.

크기가 작은 경우 리스트를 직접 생성하는 방법이 편하다.



### 바이너리 카운팅

원소 수에 해당하는 N개의 비트열을 이용한다.

n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.

```
10진수   이진수    {A, B, C, D}
  0      0000      {}
  1      0001      {A}
  2      0010      {B}
  3      0011      {B, A}
  4      0100      {C}
  5      0101      {C, A}
  6      0110      {C, B}
  7      0111      {C, B, A}
  8      1000      {D}
  9      1001      {D, A}
  10     1010      {D, B}
  11     1011      {D, B, A}
  12     1100      {D, C}
  13     1101      {D, C, A}
  14     1110      {D, C, B}
  15     1111      {C, C, B, A}
```

#### 예시 코드

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n): # 1<<n: 부분집합의 개수
    res = []
    for j in range(n): # 원소의 수만큼 비트를 비교함
        if i & (1<<j) != 0: # i의 j번째 비트가 1이면 j번째 원소 출력
            res.append(arr[j])
    print(res)
```



## 최소합

```python
f(i, j, s) # 방문하는 칸의 좌표 i, j. 이전에 지나온 칸의 합 s
	if i == N-1 and j == N-1:
        s
    else:
        if i+1 < N:
            f(i+1, j, s+arr[i][j])
        if j+1 < N:
            f(i, j+1, s+arr[i][j])
```

```python
# i, j칸까지 도착하는 최소 비용의 합
for i in range(1, N):
    for j in range(1, N):
        d[i][j] = min(d[i-1][j], d[i][j-1]) + arr[i][j]

```

